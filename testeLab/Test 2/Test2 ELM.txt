1) type alias Point = { x : Int, y : Int} 
points = [{x = 1, y = 2}, {x = 2, y = 4}, {x = 3, y = 5}]
mx : Int -> List Point -> List Point 
mx d ps = ps |> List.map(\p -> {p | x = p.x + d})

my : Int -> List Point -> List Point 
my d ps = ps |> List.map(\p -> { p | y = p.y + d }) 

points |> mx 1 |> my 2 |> List.map x |> List.foldl (+) 0
	*points = [{x = 2, y = 2}, {x = 3, y = 4}, { x = 4, y = 5}]
	*points = [{x = 2, y = 4}, {x = 3, y = 6}, { x = 4, y = 7}] 
	* [2, 3, 4] -> 2 + 3 + 4 = 9 

2) Given the following function definition: 
	f x a b = x |> a |>  b |> b 
The result of the following expression is: 
	f 3 (\x -> x + 5) (\x -> x * 2)
R : ((3 + 5) * 2 ) * 2 = 32

3) Given the following function definition: 
	f a b x = x |> b |> a 
The result of the following expression is: 
	f (\x -> x + 2)(\x -> x * 3) 2
R : (2 * 3) + 2 = 8 

4) Given the following definitions: 
	xs = [2, 1, 3] 
Select the expression(s) which will produce the following result: 
	[1, 2, 3]	

R: a) List.sort xs
c) List.reverse xs |> List.sort 
d) List.sort <| List.reverse <| xs  

5) Given the following function definition: 
	f x a b = a <| b <| x 
The result of the following expression is: 
	f 2 (\x -> x * 2) (\x -> x + 3)
R : (2 + 3) * 2 = 10

6) In the context of functions used for testing HTLM, select the functions that belong to the Html.Test.Selectors module: 
text, class, tag

(mai sunt si: id, containing, checked)

7) In the context of Elm web apps, the Msg type represents : 
-> all possible actions that can cause the app to change its state

8) Given the following definitions: 
type DivError = DivByZero 
divNums : Int -> Int -> Result DivError Int 
divNums a b = 
	if a == 0 then 	
		Err DivByZero 
	else 
		Ok(b // a)
The type of the following expressions is : 
divNums 2 10 |> Result.mapError(\_ -> "Division by zero!") -> Result String Int
divNums 2 10 |> Result.andThen (divNums 2) -> Result DivError Int
divNums 2 10 -> Result DivError Int 

9) The function countVowels can be rewritten using pipelines as: 
countVowels = List.length (List.filter isVowel (List.map Char.toLower s))
a) countVowels s = s |> List.map Char.toLower |> List.filter isVowel |> List.length
b) countVowels s = List.length <| List.filter isVowel <| List.map Char.toLower <| s 

10) Select all the true statements about the Elm runtime: 
b) Handles communication with servers
c) Handles communication with the browser

11) Select all the true statements: 
* Record accessors can be composed with function composition
* Elm has "built-in" definitions for all possible record accessors (?)
* The type of the accessor .a is {a : b} -> b 

12) To get the value inside the Just variant of Maybe or provide a default value, we can: 
* Use the Maybe.withDefault function 
* Use a case expression

13) Select all the true statements: 
* Trying to write the name of an accessor for a record that doesn't exist will result in an error 
* Records use structural typing

14) The following code snippet: 
	view = div [] [style "color" "red", text "Some text"]
* Will fail to compile
(cred ca trebuie: div [style "color" "red][text "Some text"], nu stiu sigur)

15) To compose two functions that return Result, with different error types we can: 
* Use case expressions 
* Use Result.andThen

16) Function composition operator >> takes as first parameter a FUNCTION
and second parameter a FUNCTION and returns a FUNCTION
The pipeline operator |> takes as parameter first param. a VALUE and second
parameter a VALUE and second parameter a FUNCTION and returns a VALUE

17) To transform a value that is inside the Ok variant of Result, we can: 
* Use a case expression
* Use the Result.map function 

18) The result of the following expression is: 
	type alias Point = {a: Int, b: Int}
	points = [{a = 1, b = 3}, {a = 2, b = 4}, {a = 3, b = 3}]
da: List Point -> List Point 
da ps = ps |> List.map (\p -> { p | a = p.a + p.b}) 

db: List Point -> List Point 
db ps = ps |> List.map(\p -> {p | b = p.b + p.a}) 

points |> db |> da |> List.map .b |> List.foldl (+) 0 
-> points = [{a = 1, b = 4}, {a = 2, b = 6}, {a = 3, b = 6}]
-> points = [{a = 5, b = 4}, {a = 8, b = 6}, {a = 9, b = 6}]
-> [4, 6, 6] -> suma = 4 + 6 + 6 = 16
R : 16

19) Given the following definitions: 
type CalculationError = FirstNaN | SecondNaN 
divNums: Float -> Float -> Result CalculationError Float 
divNums a b = 
	if isNaN a then 
		Err FirstNaN
	else if isNaN b then 
		Err SecondNaN
	else 
		Ok (a / b)
If we want to write a function that calls divNums and returns Result String Float, 
we have the following options: 
b) Use Result.mapError
c) (cred) Use Result.withDefault
	-> daca de ex ii dau Result.withDefault "eroare" il ia ca string (?)
d) Use a case expression to transform the error


20) Given the following definitions: 
	inc x = x + 1
	dec x = x - 1
	double x = x * 2
	twice f x = f (f x) 
What does the expression below evaluate to? 
	(twice (dec >> double >> inc)) 3 
	R : [((3 - 1) * 2 + 1) - 1] * 2 + 1 = 9 






