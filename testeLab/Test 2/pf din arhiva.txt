

Question 1 Complete
Mark 1.00 out of 1.00
Flag question
To get the value that is inside the Just variant of Maybe or provide a default value, we can:
a. Use the Maybe.unwrap function
b. Use an if expression
c. Use the Maybe.withDefault function X
d. Use a case expressionX
Your answer is correct.
Question 2
The following code snippet:
Complete
Mark 0.00 out of 1.00
Flag question
view div [] [style "color" "red", text "Some text"]
a. Will render the text "Some text" with red color
b. Will generate invalid HTML that causes the browser to show an error
c. Will render the text "Some text" with black color, because the style is not applied correctlyX
d. Will fail to compile
Your answer is incorrect.

﻿

Question 6 Complete
Mark 0.00 out of 1.00
Flag question
Given the following definitions:
type CalculationError= FirstNaN | SecondNaN
divNums Float -> Float -> Result CalculationError Float
divNums a b =
if isNaN a then
Err FirstNaN
else if isNaN b then
Err SecondNaN
else
Ok (a / b)
If we want to write a function that calls divNums and returns Result String Float, we have the following options:
a. Use a case expression to transform the error X
b. Use Result.withDefault X
c.
Use ResultmapError
d. Use Result.map


﻿

Question 5 Complete
Mark 1.00 out of 1.00
Flag question
Given the following function definition: fx a b = x |> a l> b |> b
The result of the following expression is:
f 3 (\x -> x + 5) (\x -> x * 2)
Se exec de 2 ori
Answer: 32

﻿

Question 3 Complete
Mark 1.00 out of 1.00
Flag question
The function countVowels can be rewritten using pipelines as: countVowels s = List.length (List.filter isVowel (List.map Char.toLower s))
a. countVowels s = s > List.map Char.toLower |> List.filter isVowel |> List.length X
b. countVowels s = List.length <| List.filter isVowel <| List.map Char.toLower <| s X
c.
countVowels s = s > List.length > List.filter isVowel > List.map Char.toLower d. countVowels s = List.map Char.toLower <| List.filter isVowel <| List.length <|s
Your answer is correct.
Question 4 Complete
Mark 0.00 out of 1.00
Flag question
In the context of Elm web apps, the Msg type represents:
a. All possible actions that can cause the app to change its state
b. The messages a users send in chat apps
c. The difference between two states of the app
d. The state of the app X



﻿

Question 7
Complete
Mark 0.00 out of 1.00
PFlag question
In the context of functions used for testing HTML, select the functions that belong to the Html.Test.Selectors module
a. tag
b. equal X
c. text
d. class
e. has x
Your answer is incorrect.
Given the following definitions:
Question 8
Complete
Mark 0.00 out of
dec x = x - 1
1.00
inc x = x + 1
=)(3-1)*2 + 4 = 5
=) (5-1)*2+1=9
P Flag question
double x = x * 2
twice f x = f (fx)
What does the expression below evaluate to?
(twice (dec >> double >> inc)) 3
Answer: 9


﻿

Your answer is incorrect.
Question 10
Complete
Mark 0.00 out of 1.00
Flag question
2.
The result of the following expression is:
type alias Point = {x: Int, y: Int}
points = [{x = 1, y = 2), (x = 2, y = 4}, {x = 3, y = 5}]
mx: Int -> List Point -> List Point
mx d ps = ps > List.map (\p-> {p | x = p.x + d })
my: Int -> List Point -> List Point
my d ps = ps > List.map (\p -> {ply = p.y + d })
points > mx 1 |> my 2 |> List.map .x |> List.foldl (+) 0
mx → 4x=2,y=2 √x-3y= y=4}
18
x=h, y=x
Answer: 9


﻿

Question 1 Complete
Which function describes best the each of the following list comprehensions?
[xx <- xs, length x > 2] filter
Mark 0.67 out of 1.00
P Flag question
[drop 2 x x <- xs]
[not x | x <- xs]
take
·← drop?
map
Your answer is partially correct.
You have correctly selected 2.
Question 2
Complete
Mark 1.00 out of 1.00
Flag question
Select the snippets that are valid Haskell code
a. len [] = 0
len (x:xs) = 1 + len xs  X
b. allSame: a -> a-> a-> Bool
allSame a b c = (a == b) && (b == c)
c. allSame :: Eqa · ->a->a -> a -> Bool allSame a b c = (a = == b) && (b == c)  X
d. len [] = 0
len (x::xs) = 1 + len xs

﻿

Question 3
Complete
Mark 1.00 out of 1.00
Which of the following are examples of not valid ways to create local definitions in Haskell?
a.
y * 2 where y = 5
b. local y 5 in y*2 X
Flag question
c. let y = 5 in y* 1
d. y* 2 with y = 5 X
Your answer is correct.
Question 4 Complete
Mark 1.00 out of 1.00
Flag question
Select the function that uses pattern guards correctly to implement the difference function:
a. difference [] _ = 0 X
difference (a:as) b
| a `elem' b = difference as b
| otherwise = a:difference as b
b. difference [] _ = 0
difference (a:as) b =
% a `elem` b -> difference as b
% otherwise -> a:difference as b
c. difference[] _ = []
difference (a:as) b =
if a `elem` b -> difference as b otherwise ->a:difference as b


﻿

Question 5 Complete
Mark 1.00 out of
1.00
P Flag question
Given the following function definition:
f:: [String] -> Int f[x]=1
[x", "y",""] = 2 f[x]=3
f(x)=4
f_= 5
the result of the following function call is:
[["","Y
Answer: 4

Information P Flag question
The next 3 questions are intermediate questions.
Read each question carefully.
Question 6 Complete
Mark 0.50 out of 1.00
P Flag question
Select all the false statements about the bottom value:
a. In Haskell, None is the bottom value X
b. If an expression has the bottom type, any value can be assigned to it
O c.
In Haskell, undefined is the bottom value
d. It crashes the program if it's evaluated at runtime

﻿

Question 7 Complete
The following list comprehension:
Mark 1.00 out of 1.00
Flag question
[(x, y) x <- [1, 2], y <- ['a', 'b']]
a. Returns [(1, 'a'), (2, 'b')]
b. Returns: [(1, 'a'), (1, 'b'), (2, 'a'), (2, 'b')] X
c. Fails to combile because the syntax is invalid
d. Fails to combile because x and y have different types
Your answer is correct.
Question 8 Complete
Mark 1.00 out of 1.00
Flag question
Select all the false statements about type classes
a. Type classes are used to define classes, a special kind of data definition that includes methods and private fields X
b. Type classes are used to abstract common behavior for various types (like Java interfaces)
c.
All instance implementations for a type class must be in the module where the type class X
d. We can implement type classes defined by the standard library for our own types

﻿

Question 9 Complete
Mark 1.00 out of 1.00
Flag question
Given the following code that generates the hamming numbers:
merge3 x y z = merge (merge x y) z where
merge (u:us) (v:vs)
| u< v = u: merge us (v: vs)
| u > v = v:merge (u:us) vs
| otherwise = u: merge us vs
ham :: [Integer] ham
1:merge3 ham2 ham3 ham5
ham2 = [ 2*i | i <- ham ]
ham3
=
[3*ii <-ham ]
ham5= [ 5*i | i <- ham ]
hammingGen :: Int -> [Integer]
hammingGen n = take n ham
Select what will be printed for each of the following commands after evaluating: hammingGen 3
> : sprint ham3 ham3 =3:_
> : sprint ham2
ham2 =2:4:_

﻿

Question 10 Complete
Mark 1.00 out of
1.00
Flag question
Given the following code:
newtype Any
Any Bool
instance Semigroup Any where
(Any a) <> (Any b) = Any (a || b) instance Monoid Any where
mempty
Any False
The result of the following expressions is:
foldl (<>) mempty (map (x -> Any (x mod 2 == 0)) [1, 2, 3])
Any True
foldl (<>) mempty (map (\x -> Any (x >= 2)) [2, 3, 4])
Any True
Your answer is correct.


﻿

Question 1 Complete
Match the concepts:
Mark 0.33 out of1.00
Mappable types that can also unpack nested structures in results Applicative

Mappable types  Functor
Generalized mappable types Monad

Your answer is partially correct.
You have correctly selected 1.
Question 2 Complete
Mark 1.00 out of 1.00
P Flag question
Select all the false statements about Input/Output in Haskell
a. To read data from a file we use the read function X
b. To obtain a line from the standard input, we can write
do
name <getLine
putStrLn name
c. do notation can be only used with the IO monad X
d. Haskell's main function has the signature main :: 10 (
Your answer is correct.


﻿

Question 3 Complete
Mark 1.00 out of
1.00
Flag question
Select the false statements about monads in Haskell:
a. Monad defines the function <$> X
b. Int is an example of Monad X
c.
Maybe is an example of a Monad
d. Monad is a type class
Your answer is correct.
Question 4
Complete
Mark 1.00 out of
1.00
Which of the following names would best describe the following parser: satisfies (==c)
a. upper
Flag question
b. digit
c. lower
d. char X
Your answer is correct.

﻿

Question 5 Complete
Mark 1.00 out of
1.00
Flag question
Select the function signature that best represents a parser
a. String -> Result ParseError (a, String) X
b. [Int] -> Result Int a
c. String> Result ParseError a
d. String -> a
Your answer is correct.
Information
Flag question
The next 3 questions are intermediate questions.
Read each question carefully.
Question 6
Complete
Mark 1.00 out of 1.00
Complete the parser below such that it parses a C\C++ array indexing expression (i.e. [1][2]):
Note: there must be at least one indexing expression.
cArrayIndex = some
$ between
(char '[') # (char ']') # number
Flag question
Your answer is correct.






module Balea_Cristian_1 exposing (..)


-- Exercitiul 1

impar : Int -> Bool
impar i =
  if i == 0 then False
  else if i == 1 then True
  else impar (i - 2)

sumaImpare : List Int -> Int
sumaImpare l =
  let 
    sumaImpareHelp list suma =
      case list of
        [] -> suma
        x::xs -> if (impar x) then sumaImpareHelp xs (suma + x)
                 else sumaImpareHelp xs suma
  in
    sumaImpareHelp l 0

-- Apel functie: 
-- > sumaImpare [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
-- 25 : Int
-- > sumaImpare [2, 4, 6, 8]
-- 0 : Int








-- Exercitiul 2

reverse lista = 
  let
    reverseH list aux = 
      case list of
        [] -> aux
        x::xs -> (reverseH xs aux) ++ [x]
  in
    reverseH lista []


length list = 
  let
    lengthHelp l acc = 
      case l of
        [] -> acc
        x::xs -> lengthHelp xs (acc + 1)
  in 
    lengthHelp list 0

addPair : List Int -> List Int -> List Int
addPair lista1 lista2 =
  let
    addPairHelp l1 l2 aux =
      case (l1, l2) of
        ([], []) -> reverse aux
        (x::xs, y::ys) -> addPairHelp xs ys ((x + y)::aux)
        (_, _) -> []
  in
    if length lista1 == length lista2 then addPairHelp lista1 lista2 []
    else []

-- Apel functie
-- > addPair [1, 2, 3, 4, 5] [6, 7, 8, 9, 10]
-- [7,9,11,13,15] : List Int








-- Exercitiul 3
head lista =
      case lista of
        x :: xs -> x
        [] -> -1


minList : List Int -> Int
minList l = 
  let 
    minListH list min =
      case list of
        [] -> min
        x::xs -> if x <= min then minListH xs x
                 else minListH xs min
    
  in
    minListH l (head l)


-- Apel functie
-- > minList [10, 100, 22, 14, 2, 50, 90, 1, 101, 1001]
-- 1 : Int
-- > minList [10, 100, 22, 14, 2, 50, 90, 101, 1001]   
-- 2 : Int











-- Exercitiul 4

checkPalindrom : List Int -> Bool
checkPalindrom list =
  let
    check l1 l2 =
      case (l1, l2) of
      ([], []) -> True
      (x::xs, y::ys) -> if x == y then check xs ys else False 
      (_, _) -> False
  in
    check list (reverse list)

-- Apel functie
-- > checkPalindrom [1, 2, 3, 4, 5, 4, 3, 2, 1]
-- True : Bool
-- > checkPalindrom [1, 2, 3, 4, 5, 4, 3, 2]   
-- False : Bool












-- Exercitiul 5

prim : Int -> Bool
prim n =
  let
    primHelp x i = 
      if x == 2 then True
      else if i == x - 1 then True
      else if x == 1 || x == 0 then False
      else if ((modBy i x) == 0) then False
      else primHelp x (i + 1)
  in 
    primHelp n 2


extract : List Int -> Int -> Int -> List Int
extract lista start end = 
  let
    extractHelp l s e aux =
      case l of
        [] -> aux
        x::xs -> if ((prim x) && s <= x && x <= e) then extractHelp xs s e (x::aux)
                 else extractHelp xs s e aux 
  in
    extractHelp lista start end []


-- Apelul functiei
-- > extract [9, 7, 1, 4, 5, 6, 3, 2, 8] 4 8
-- [5,7] : List Int
-- > extract [9, 7, 1, 4, 5, 6, 3, 2, 8] 2 4
-- [2,3] : List Int
-- > extract [9, 7, 1, 4, 5, 6, 3, 2, 8] 20 30
-- [] : List Int
-- > extract [9, 7, 1, 4, 5, 6, 3, 2, 8] 1 10 
-- [2,3,5,7] : List Int












-- Exercitiul 6

closestPrim : Int -> Int
closestPrim numar = 
  let
    closeHelp n p = 
      if prim p then p else closeHelp n (p - 1)
  in
    closeHelp numar (numar - 1)

goldbach : Int -> (Int, Int)
goldbach numar = 
  let 
    goldHelp n p1 p2 =
      if p1 + p2 == n && prim p1 && prim p2 then (p1, p2)
      else if (prim p1) == False && (prim p2) == False then goldHelp n (p1 + 1) (p2 - 1)
      else if prim p2 == False then goldHelp n p1 (p2 - 1)
      else if prim p1 == False then goldHelp n (p1 +1) p2
      else goldHelp n (p1+1) (p2-1)
  in
    goldHelp numar 2 (closestPrim numar)


-- Apel functie 
-- > goldbach 28
-- (5,23) : ( Int, Int )
-- > goldbach 6
-- (3,3) : ( Int, Int )
